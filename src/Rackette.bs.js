// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackette$Rackette = require("./CS17SetupRackette.bs.js");

var initialTle_0 = {
  hd: [
    /* Name */{
      _0: "+"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        printedRep: "<builtin-proc-+>",
        bProc: (function (param) {
            if (!param) {
              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
            }
            var n1 = param.hd;
            if (n1.TAG === /* NumV */0) {
              var match = param.tl;
              if (!match) {
                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
              }
              var n2 = match.hd;
              if (n2.TAG === /* NumV */0) {
                if (match.tl) {
                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                } else {
                  return {
                          TAG: /* NumV */0,
                          _0: n1._0 + n2._0 | 0
                        };
                }
              }
              
            }
            var match$1 = param.tl;
            if (match$1 && !match$1.tl) {
              return Pervasives.failwith("Incorrect input type: expected numbers");
            } else {
              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
            }
          })
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "-"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          printedRep: "<builtin-proc-->",
          bProc: (function (param) {
              if (!param) {
                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
              }
              var n1 = param.hd;
              if (n1.TAG === /* NumV */0) {
                var match = param.tl;
                if (!match) {
                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                }
                var n2 = match.hd;
                if (n2.TAG === /* NumV */0) {
                  if (match.tl) {
                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                  } else {
                    return {
                            TAG: /* NumV */0,
                            _0: n1._0 - n2._0 | 0
                          };
                  }
                }
                
              }
              var match$1 = param.tl;
              if (match$1 && !match$1.tl) {
                return Pervasives.failwith("Incorrect input type: expected numbers");
              } else {
                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
              }
            })
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "*"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            printedRep: "<builtin-proc-*>",
            bProc: (function (param) {
                if (!param) {
                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                }
                var n1 = param.hd;
                if (n1.TAG === /* NumV */0) {
                  var match = param.tl;
                  if (!match) {
                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                  }
                  var n2 = match.hd;
                  if (n2.TAG === /* NumV */0) {
                    if (match.tl) {
                      return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                    } else {
                      return {
                              TAG: /* NumV */0,
                              _0: Math.imul(n1._0, n2._0)
                            };
                    }
                  }
                  
                }
                var match$1 = param.tl;
                if (match$1 && !match$1.tl) {
                  return Pervasives.failwith("Incorrect input type: expected numbers");
                } else {
                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                }
              })
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "/"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              printedRep: "<builtin-proc-/>",
              bProc: (function (param) {
                  if (!param) {
                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                  }
                  var n1 = param.hd;
                  if (n1.TAG === /* NumV */0) {
                    var match = param.tl;
                    if (!match) {
                      return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                    }
                    var n2 = match.hd;
                    if (n2.TAG === /* NumV */0) {
                      if (match.tl) {
                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                      } else {
                        return {
                                TAG: /* NumV */0,
                                _0: Caml_int32.div(n1._0, n2._0)
                              };
                      }
                    }
                    
                  }
                  var match$1 = param.tl;
                  if (match$1 && !match$1.tl) {
                    return Pervasives.failwith("Incorrect input type: expected numbers");
                  } else {
                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                  }
                })
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "remainder"
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                printedRep: "<builtin-proc-remainder>",
                bProc: (function (param) {
                    if (!param) {
                      return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                    }
                    var n1 = param.hd;
                    if (n1.TAG === /* NumV */0) {
                      var match = param.tl;
                      if (!match) {
                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                      }
                      var n2 = match.hd;
                      if (n2.TAG === /* NumV */0) {
                        if (match.tl) {
                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                        } else {
                          return {
                                  TAG: /* NumV */0,
                                  _0: Caml_int32.mod_(n1._0, n2._0)
                                };
                        }
                      }
                      
                    }
                    var match$1 = param.tl;
                    if (match$1 && !match$1.tl) {
                      return Pervasives.failwith("Incorrect input type: expected numbers");
                    } else {
                      return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                    }
                  })
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "="
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  printedRep: "<builtin-proc-=>",
                  bProc: (function (param) {
                      if (!param) {
                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                      }
                      var n1 = param.hd;
                      if (n1.TAG === /* NumV */0) {
                        var match = param.tl;
                        if (!match) {
                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                        }
                        var n2 = match.hd;
                        if (n2.TAG === /* NumV */0) {
                          if (match.tl) {
                            return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                          } else {
                            return {
                                    TAG: /* BoolV */1,
                                    _0: n1._0 === n2._0
                                  };
                          }
                        }
                        
                      }
                      var match$1 = param.tl;
                      if (match$1 && !match$1.tl) {
                        return Pervasives.failwith("Incorrect input type: expected numbers");
                      } else {
                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                      }
                    })
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "<"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    printedRep: "<builtin-proc-<>",
                    bProc: (function (param) {
                        if (!param) {
                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                        }
                        var n1 = param.hd;
                        if (n1.TAG === /* NumV */0) {
                          var match = param.tl;
                          if (!match) {
                            return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                          }
                          var n2 = match.hd;
                          if (n2.TAG === /* NumV */0) {
                            if (match.tl) {
                              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                            } else {
                              return {
                                      TAG: /* BoolV */1,
                                      _0: n1._0 < n2._0
                                    };
                            }
                          }
                          
                        }
                        var match$1 = param.tl;
                        if (match$1 && !match$1.tl) {
                          return Pervasives.failwith("Incorrect input type: expected numbers");
                        } else {
                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                        }
                      })
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "<="
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      printedRep: "<builtin-proc-<=>",
                      bProc: (function (param) {
                          if (!param) {
                            return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                          }
                          var n1 = param.hd;
                          if (n1.TAG === /* NumV */0) {
                            var match = param.tl;
                            if (!match) {
                              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                            }
                            var n2 = match.hd;
                            if (n2.TAG === /* NumV */0) {
                              if (match.tl) {
                                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                              } else {
                                return {
                                        TAG: /* BoolV */1,
                                        _0: n1._0 <= n2._0
                                      };
                              }
                            }
                            
                          }
                          var match$1 = param.tl;
                          if (match$1 && !match$1.tl) {
                            return Pervasives.failwith("Incorrect input type: expected numbers");
                          } else {
                            return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                          }
                        })
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: ">"
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        printedRep: "<builtin-proc->>",
                        bProc: (function (param) {
                            if (!param) {
                              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                            }
                            var n1 = param.hd;
                            if (n1.TAG === /* NumV */0) {
                              var match = param.tl;
                              if (!match) {
                                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                              }
                              var n2 = match.hd;
                              if (n2.TAG === /* NumV */0) {
                                if (match.tl) {
                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                } else {
                                  return {
                                          TAG: /* BoolV */1,
                                          _0: n1._0 > n2._0
                                        };
                                }
                              }
                              
                            }
                            var match$1 = param.tl;
                            if (match$1 && !match$1.tl) {
                              return Pervasives.failwith("Incorrect input type: expected numbers");
                            } else {
                              return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                            }
                          })
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: ">="
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          printedRep: "<builtin-proc->=>",
                          bProc: (function (param) {
                              if (!param) {
                                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                              }
                              var n1 = param.hd;
                              if (n1.TAG === /* NumV */0) {
                                var match = param.tl;
                                if (!match) {
                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                }
                                var n2 = match.hd;
                                if (n2.TAG === /* NumV */0) {
                                  if (match.tl) {
                                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                  } else {
                                    return {
                                            TAG: /* BoolV */1,
                                            _0: n1._0 >= n2._0
                                          };
                                  }
                                }
                                
                              }
                              var match$1 = param.tl;
                              if (match$1 && !match$1.tl) {
                                return Pervasives.failwith("Incorrect input type: expected numbers");
                              } else {
                                return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                              }
                            })
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "equal?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            printedRep: "<builtin-proc-equal?>",
                            bProc: (function (param) {
                                if (!param) {
                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                }
                                var n1 = param.hd;
                                switch (n1.TAG | 0) {
                                  case /* NumV */0 :
                                      var match = param.tl;
                                      if (!match) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                      }
                                      var n2 = match.hd;
                                      if (n2.TAG === /* NumV */0) {
                                        if (match.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                        } else {
                                          return {
                                                  TAG: /* BoolV */1,
                                                  _0: n1._0 === n2._0
                                                };
                                        }
                                      }
                                      break;
                                  case /* BoolV */1 :
                                      var match$1 = param.tl;
                                      if (!match$1) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                      }
                                      var b2 = match$1.hd;
                                      if (b2.TAG === /* BoolV */1) {
                                        if (match$1.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                        } else {
                                          return {
                                                  TAG: /* BoolV */1,
                                                  _0: n1._0 === b2._0
                                                };
                                        }
                                      }
                                      break;
                                  case /* ListV */2 :
                                      var match$2 = param.tl;
                                      if (!match$2) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                      }
                                      var l2 = match$2.hd;
                                      if (l2.TAG === /* ListV */2) {
                                        if (match$2.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                        } else {
                                          return {
                                                  TAG: /* BoolV */1,
                                                  _0: Caml_obj.caml_equal(n1._0, l2._0)
                                                };
                                        }
                                      }
                                      break;
                                  case /* BuiltinV */3 :
                                      var match$3 = param.tl;
                                      if (!match$3) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                      }
                                      var bi2 = match$3.hd;
                                      if (bi2.TAG === /* BuiltinV */3) {
                                        if (match$3.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                        } else {
                                          return {
                                                  TAG: /* BoolV */1,
                                                  _0: Caml_obj.caml_equal(n1._0, bi2._0)
                                                };
                                        }
                                      }
                                      break;
                                  case /* ClosureV */4 :
                                      var match$4 = param.tl;
                                      if (!match$4) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                      }
                                      var c2 = match$4.hd;
                                      if (c2.TAG === /* ClosureV */4) {
                                        if (match$4.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                        } else {
                                          return {
                                                  TAG: /* BoolV */1,
                                                  _0: Caml_obj.caml_equal(n1._0, c2._0)
                                                };
                                        }
                                      }
                                      break;
                                  
                                }
                                if (param.tl.tl) {
                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                } else {
                                  return {
                                          TAG: /* BoolV */1,
                                          _0: false
                                        };
                                }
                              })
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "number?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              printedRep: "<builtin-proc-number?>",
                              bProc: (function (param) {
                                  if (param) {
                                    if (param.hd.TAG === /* NumV */0) {
                                      if (param.tl) {
                                        return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                      } else {
                                        return {
                                                TAG: /* BoolV */1,
                                                _0: true
                                              };
                                      }
                                    } else if (param.tl) {
                                      return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                    } else {
                                      return {
                                              TAG: /* BoolV */1,
                                              _0: false
                                            };
                                    }
                                  } else {
                                    return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                  }
                                })
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "zero?"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                printedRep: "<builtin-proc-zero?>",
                                bProc: (function (param) {
                                    if (!param) {
                                      return Pervasives.failwith("incorrect number of inputs");
                                    }
                                    var n = param.hd;
                                    if (n.TAG === /* NumV */0) {
                                      if (param.tl) {
                                        return Pervasives.failwith("incorrect number of inputs");
                                      } else {
                                        return {
                                                TAG: /* BoolV */1,
                                                _0: n._0 === 0
                                              };
                                      }
                                    } else if (param.tl) {
                                      return Pervasives.failwith("incorrect number of inputs");
                                    } else {
                                      return Pervasives.failwith("incorrect input type; expected a number");
                                    }
                                  })
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "cons"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  printedRep: "<builtin-proc-cons>",
                                  bProc: (function (param) {
                                      if (!param) {
                                        return Pervasives.failwith("incorrect number of inputs or incorrect input type");
                                      }
                                      var match = param.tl;
                                      if (!match) {
                                        return Pervasives.failwith("incorrect number of inputs or incorrect input type");
                                      }
                                      var l = match.hd;
                                      if (l.TAG === /* ListV */2 && !match.tl) {
                                        return {
                                                TAG: /* ListV */2,
                                                _0: {
                                                  hd: param.hd,
                                                  tl: l._0
                                                }
                                              };
                                      } else {
                                        return Pervasives.failwith("incorrect number of inputs or incorrect input type");
                                      }
                                    })
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "first"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    printedRep: "<builtin-proc-first>",
                                    bProc: (function (param) {
                                        if (!param) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                        }
                                        var l = param.hd;
                                        if (l.TAG !== /* ListV */2) {
                                          if (param.tl) {
                                            return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                          } else {
                                            return Pervasives.failwith("incorrect input type: expected a list");
                                          }
                                        }
                                        if (param.tl) {
                                          return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                        }
                                        var l$1 = l._0;
                                        if (l$1) {
                                          return l$1.hd;
                                        } else {
                                          return Pervasives.failwith("this procedure expects a non-empty list input");
                                        }
                                      })
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "rest"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      printedRep: "<builtin-proc-rest>",
                                      bProc: (function (param) {
                                          if (!param) {
                                            return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                          }
                                          var l = param.hd;
                                          if (l.TAG !== /* ListV */2) {
                                            if (param.tl) {
                                              return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                            } else {
                                              return Pervasives.failwith("incorrect input type: expected a list");
                                            }
                                          }
                                          if (param.tl) {
                                            return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                          }
                                          var l$1 = l._0;
                                          if (l$1) {
                                            return {
                                                    TAG: /* ListV */2,
                                                    _0: l$1.tl
                                                  };
                                          } else {
                                            return Pervasives.failwith("this procedure expects a non-empty list input");
                                          }
                                        })
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "empty?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        printedRep: "<builtin-proc-empty?>",
                                        bProc: (function (param) {
                                            if (!param) {
                                              return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                            }
                                            var match = param.hd;
                                            if (match.TAG === /* ListV */2) {
                                              if (match._0) {
                                                if (param.tl) {
                                                  return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                                } else {
                                                  return {
                                                          TAG: /* BoolV */1,
                                                          _0: false
                                                        };
                                                }
                                              } else if (param.tl) {
                                                return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                              } else {
                                                return {
                                                        TAG: /* BoolV */1,
                                                        _0: true
                                                      };
                                              }
                                            } else if (param.tl) {
                                              return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                            } else {
                                              return {
                                                      TAG: /* BoolV */1,
                                                      _0: false
                                                    };
                                            }
                                          })
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "cons?"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          printedRep: "<builtin-proc-cons?>",
                                          bProc: (function (param) {
                                              if (!param) {
                                                return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                              }
                                              var match = param.hd;
                                              if (match.TAG === /* ListV */2) {
                                                if (match._0) {
                                                  if (param.tl) {
                                                    return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                                  } else {
                                                    return {
                                                            TAG: /* BoolV */1,
                                                            _0: true
                                                          };
                                                  }
                                                } else if (param.tl) {
                                                  return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                                } else {
                                                  return {
                                                          TAG: /* BoolV */1,
                                                          _0: false
                                                        };
                                                }
                                              } else if (param.tl) {
                                                return Pervasives.failwith("incorrect number of inputs: expected 1 argument");
                                              } else {
                                                return {
                                                        TAG: /* BoolV */1,
                                                        _0: false
                                                      };
                                              }
                                            })
                                        }
                                      }
                                    ],
                                    tl: {
                                      hd: [
                                        /* Name */{
                                          _0: "not"
                                        },
                                        {
                                          TAG: /* BuiltinV */3,
                                          _0: {
                                            printedRep: "<builtin-proc-not>",
                                            bProc: (function (param) {
                                                if (!param) {
                                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                                }
                                                var b = param.hd;
                                                if (b.TAG === /* BoolV */1) {
                                                  if (param.tl) {
                                                    return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                                  } else if (b._0) {
                                                    return {
                                                            TAG: /* BoolV */1,
                                                            _0: false
                                                          };
                                                  } else {
                                                    return {
                                                            TAG: /* BoolV */1,
                                                            _0: true
                                                          };
                                                  }
                                                } else if (param.tl) {
                                                  return Pervasives.failwith("incorrect number of inputs: expected 2 arguments");
                                                } else {
                                                  return Pervasives.failwith("incorrect input type: expected a boolean");
                                                }
                                              })
                                          }
                                        }
                                      ],
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: /* [] */0
};

function containsDuplicates(_input) {
  while(true) {
    var input = _input;
    if (!input) {
      return false;
    }
    var restItems = input.tl;
    var firstItem = input.hd;
    var containedIn = (function(firstItem){
    return function containedIn(_lst) {
      while(true) {
        var lst = _lst;
        if (!lst) {
          return false;
        }
        if (Caml_obj.caml_equal(lst.hd, firstItem)) {
          return true;
        }
        _lst = lst.tl;
        continue ;
      };
    }
    }(firstItem));
    if (containedIn(restItems)) {
      return true;
    }
    _input = restItems;
    continue ;
  };
}

CS17SetupRackette$Rackette.checkExpect(containsDuplicates(/* [] */0), false, "no duplicates found in empty list");

CS17SetupRackette$Rackette.checkExpect(containsDuplicates({
          hd: 1,
          tl: {
            hd: 2,
            tl: {
              hd: 3,
              tl: /* [] */0
            }
          }
        }), false, "no duplicates found");

CS17SetupRackette$Rackette.checkExpect(containsDuplicates({
          hd: 1,
          tl: {
            hd: 2,
            tl: {
              hd: 3,
              tl: {
                hd: 2,
                tl: /* [] */0
              }
            }
          }
        }), true, "duplicates found");

CS17SetupRackette$Rackette.checkExpect(containsDuplicates({
          hd: "a",
          tl: {
            hd: "b",
            tl: /* [] */0
          }
        }), false, "no duplicates found");

CS17SetupRackette$Rackette.checkExpect(containsDuplicates({
          hd: "a",
          tl: {
            hd: "a",
            tl: /* [] */0
          }
        }), true, "duplicates found");

CS17SetupRackette$Rackette.checkExpect(containsDuplicates({
          hd: "a",
          tl: {
            hd: "a",
            tl: {
              hd: "b",
              tl: {
                hd: "b",
                tl: /* [] */0
              }
            }
          }
        }), true, "duplicates found");

function lookup(_env, n) {
  while(true) {
    var env = _env;
    if (!env) {
      return ;
    }
    var lookupWithin = function (_bl, lookingFor) {
      while(true) {
        var bl = _bl;
        if (!bl) {
          return ;
        }
        var firstBinding = bl.hd;
        if (Caml_obj.caml_equal(firstBinding[0], lookingFor)) {
          return firstBinding[1];
        }
        _bl = bl.tl;
        continue ;
      };
    };
    var y = lookupWithin(env.hd, n);
    if (y !== undefined) {
      return y;
    }
    _env = env.tl;
    continue ;
  };
}

var test = {
  hd: {
    hd: [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumV */0,
        _0: 1
      }
    ],
    tl: /* [] */0
  },
  tl: {
    hd: {
      hd: [
        /* Name */{
          _0: "y"
        },
        {
          TAG: /* NumV */0,
          _0: 2
        }
      ],
      tl: /* [] */0
    },
    tl: /* [] */0
  }
};

CS17SetupRackette$Rackette.checkExpect(lookup(initialTle, /* Name */{
          _0: ")"
        }), undefined, "return None");

CS17SetupRackette$Rackette.checkExpect(lookup(test, /* Name */{
          _0: "x"
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "returns value of x (exists in environment)");

function parseExpression(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
        return {
                TAG: /* NumE */0,
                _0: input._0
              };
    case /* SymbolC */1 :
        var x = input._0;
        switch (x) {
          case "empty" :
              return /* EmptyE */0;
          case "false" :
              return {
                      TAG: /* BoolE */1,
                      _0: false
                    };
          case "true" :
              return {
                      TAG: /* BoolE */1,
                      _0: true
                    };
          default:
            return {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: x
                    }
                  };
        }
    case /* ListC */2 :
        var l = input._0;
        if (!l) {
          return Pervasives.failwith("empty parentheses are not allowed as an input");
        }
        var match = l.hd;
        switch (match.TAG | 0) {
          case /* SymbolC */1 :
              switch (match._0) {
                case "and" :
                    var match$1 = l.tl;
                    if (!match$1) {
                      return Pervasives.failwith("and requires 2 subexpressions");
                    }
                    var match$2 = match$1.tl;
                    if (match$2 && !match$2.tl) {
                      return {
                              TAG: /* AndE */3,
                              _0: parseExpression(match$1.hd),
                              _1: parseExpression(match$2.hd)
                            };
                    } else {
                      return Pervasives.failwith("and requires 2 subexpressions");
                    }
                case "cond" :
                    return {
                            TAG: /* CondE */6,
                            _0: List.map((function (c) {
                                    switch (c.TAG | 0) {
                                      case /* NumberC */0 :
                                      case /* SymbolC */1 :
                                          return Pervasives.failwith("Cond clause expects: [test, expr]");
                                      case /* ListC */2 :
                                          var match = c._0;
                                          if (!match) {
                                            return Pervasives.failwith("Cond clause expects: [test, expr]");
                                          }
                                          var match$1 = match.tl;
                                          if (match$1 && !match$1.tl) {
                                            return {
                                                    conditionExpr: parseExpression(match.hd),
                                                    resultExpr: parseExpression(match$1.hd)
                                                  };
                                          } else {
                                            return Pervasives.failwith("Cond clause expects: [test, expr]");
                                          }
                                      
                                    }
                                  }), l.tl)
                          };
                case "if" :
                    var match$3 = l.tl;
                    if (!match$3) {
                      return Pervasives.failwith("if requires 3 subexpressions");
                    }
                    var match$4 = match$3.tl;
                    if (!match$4) {
                      return Pervasives.failwith("if requires 3 subexpressions");
                    }
                    var match$5 = match$4.tl;
                    if (match$5 && !match$5.tl) {
                      return {
                              TAG: /* IfE */5,
                              _0: {
                                boolExpr: parseExpression(match$3.hd),
                                trueExpr: parseExpression(match$4.hd),
                                falseExpr: parseExpression(match$5.hd)
                              }
                            };
                    } else {
                      return Pervasives.failwith("if requires 3 subexpressions");
                    }
                case "lambda" :
                    var match$6 = l.tl;
                    if (!match$6) {
                      return Pervasives.failwith("invalid lambda syntax");
                    }
                    var parameters = match$6.hd;
                    switch (parameters.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("invalid lambda syntax");
                      case /* ListC */2 :
                          var match$7 = match$6.tl;
                          if (match$7 && !match$7.tl) {
                            return {
                                    TAG: /* LambdaE */7,
                                    _0: {
                                      nameList: List.map((function (p) {
                                              switch (p.TAG | 0) {
                                                case /* SymbolC */1 :
                                                    return /* Name */{
                                                            _0: p._0
                                                          };
                                                case /* NumberC */0 :
                                                case /* ListC */2 :
                                                    return Pervasives.failwith("Incorrect Syntax");
                                                
                                              }
                                            }), parameters._0),
                                      lambdaBody: parseExpression(match$7.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("invalid lambda syntax");
                          }
                      
                    }
                case "let" :
                    var match$8 = l.tl;
                    if (!match$8) {
                      return Pervasives.failwith("invalid let syntax");
                    }
                    var pairs = match$8.hd;
                    switch (pairs.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("invalid let syntax");
                      case /* ListC */2 :
                          var match$9 = match$8.tl;
                          if (match$9 && !match$9.tl) {
                            return {
                                    TAG: /* LetE */8,
                                    _0: {
                                      letPairs: List.map((function (p) {
                                              switch (p.TAG | 0) {
                                                case /* NumberC */0 :
                                                case /* SymbolC */1 :
                                                    return Pervasives.failwith("Syntax Error");
                                                case /* ListC */2 :
                                                    var match = p._0;
                                                    if (!match) {
                                                      return Pervasives.failwith("Syntax Error");
                                                    }
                                                    var x = match.hd;
                                                    switch (x.TAG | 0) {
                                                      case /* SymbolC */1 :
                                                          var match$1 = match.tl;
                                                          if (match$1 && !match$1.tl) {
                                                            return {
                                                                    pairName: /* Name */{
                                                                      _0: x._0
                                                                    },
                                                                    pairExpr: parseExpression(match$1.hd)
                                                                  };
                                                          } else {
                                                            return Pervasives.failwith("Syntax Error");
                                                          }
                                                      case /* NumberC */0 :
                                                      case /* ListC */2 :
                                                          return Pervasives.failwith("Syntax Error");
                                                      
                                                    }
                                                
                                              }
                                            }), pairs._0),
                                      letBody: parseExpression(match$9.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("invalid let syntax");
                          }
                      
                    }
                case "or" :
                    var match$10 = l.tl;
                    if (!match$10) {
                      return Pervasives.failwith("or requires 2 subexpressions");
                    }
                    var match$11 = match$10.tl;
                    if (match$11 && !match$11.tl) {
                      return {
                              TAG: /* OrE */4,
                              _0: parseExpression(match$10.hd),
                              _1: parseExpression(match$11.hd)
                            };
                    } else {
                      return Pervasives.failwith("or requires 2 subexpressions");
                    }
                default:
                  return {
                          TAG: /* ApplicationE */9,
                          _0: List.map(parseExpression, l)
                        };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* ApplicationE */9,
                      _0: List.map(parseExpression, l)
                    };
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression(Read$Rackette.Reader.read("(lambda (x 3) x)"));
      }), "Incorrect Syntax");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression(Read$Rackette.Reader.read("(cond ((> 1 0)))"));
      }), "Cond clause expects: [test, expr]");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression(Read$Rackette.Reader.read("(let ((x)) x)"));
      }), "Syntax Error");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse empty expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("empty")), /* EmptyE */0, "read and parse empty expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("5")), {
      TAG: /* NumE */0,
      _0: 5
    }, "Parses number");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("true")), {
      TAG: /* BoolE */1,
      _0: true
    }, "Parses true");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("false")), {
      TAG: /* BoolE */1,
      _0: false
    }, "Parses false");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("empty")), /* EmptyE */0, "Parses empty");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("x")), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "x"
      }
    }, "Parses variable name");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(if true 1 2)")), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* BoolE */1,
          _0: true
        },
        trueExpr: {
          TAG: /* NumE */0,
          _0: 1
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 2
        }
      }
    }, "Parses if-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(and true false)")), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "Parses and-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(or false true)")), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "Parses or-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x y) (+ x y))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "Parses lambda-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x) (lambda (y) (+ x y)))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "y"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "y"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      }
    }, "Parses nested lambda inside another lambda");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(((lambda (x) (lambda (y) (+ x y))) 5) 10)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* LambdaE */7,
                  _0: {
                    nameList: {
                      hd: /* Name */{
                        _0: "y"
                      },
                      tl: /* [] */0
                    },
                    lambdaBody: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "+"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "x"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "y"
                              }
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 10
          },
          tl: /* [] */0
        }
      }
    }, "Parses nested lambda applications correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(cond ((> 3 2) 1) ((< 3 2) 0))")), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: ">"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 3
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 2
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          resultExpr: {
            TAG: /* NumE */0,
            _0: 1
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "<"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 3
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 2
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 0
            }
          },
          tl: /* [] */0
        }
      }
    }, "Parses cond-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5) (y 7)) (+ x y))")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 7
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "Parses let-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(+ 1 2)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 2
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses addition application");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(* 3 4)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "*"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 3
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 4
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses multiplication application");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(* (+ 1 2) (- 5 3))")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "*"
          }
        },
        tl: {
          hd: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 2
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "-"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 5
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses nested applications correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(cons 1 empty)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "cons"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: /* EmptyE */0,
            tl: /* [] */0
          }
        }
      }
    }, "Parses cons expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(first (cons 1 empty))")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "first"
          }
        },
        tl: {
          hd: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "cons"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: {
                  hd: /* EmptyE */0,
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }
      }
    }, "Parses first expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(empty? empty)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "empty?"
          }
        },
        tl: {
          hd: /* EmptyE */0,
          tl: /* [] */0
        }
      }
    }, "Parses empty? correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(not true)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "not"
          }
        },
        tl: {
          hd: {
            TAG: /* BoolE */1,
            _0: true
          },
          tl: /* [] */0
        }
      }
    }, "Parses not-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse empty expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "Parses empty");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* NumberC */0,
          _0: 5
        }), {
      TAG: /* NumE */0,
      _0: 5
    }, "Parses number");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "true"
        }), {
      TAG: /* BoolE */1,
      _0: true
    }, "Parses true");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "false"
        }), {
      TAG: /* BoolE */1,
      _0: false
    }, "Parses false");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "x"
        }), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "x"
      }
    }, "Parses variable name");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 1
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 2
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* BoolE */1,
          _0: true
        },
        trueExpr: {
          TAG: /* NumE */0,
          _0: 1
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 2
        }
      }
    }, "Parses if-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "Parses and-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "Parses or-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "x"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "y"
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "y"
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "Parses lambda-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "x"
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "y"
                          },
                          tl: /* [] */0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "y"
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "y"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "y"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      }
    }, "Parses nested lambda inside another lambda");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "x"
                          },
                          tl: /* [] */0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "lambda"
                            },
                            tl: {
                              hd: {
                                TAG: /* ListC */2,
                                _0: {
                                  hd: {
                                    TAG: /* SymbolC */1,
                                    _0: "y"
                                  },
                                  tl: /* [] */0
                                }
                              },
                              tl: {
                                hd: {
                                  TAG: /* ListC */2,
                                  _0: {
                                    hd: {
                                      TAG: /* SymbolC */1,
                                      _0: "+"
                                    },
                                    tl: {
                                      hd: {
                                        TAG: /* SymbolC */1,
                                        _0: "x"
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* SymbolC */1,
                                          _0: "y"
                                        },
                                        tl: /* [] */0
                                      }
                                    }
                                  }
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 5
                  },
                  tl: /* [] */0
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 10
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* LambdaE */7,
                  _0: {
                    nameList: {
                      hd: /* Name */{
                        _0: "y"
                      },
                      tl: /* [] */0
                    },
                    lambdaBody: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "+"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "x"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "y"
                              }
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 10
          },
          tl: /* [] */0
        }
      }
    }, "Parses nested lambda applications correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "let"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "y"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 7
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "y"
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 7
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "Parses let-expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "+"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 2
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses addition application");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "*"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 3
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 4
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "*"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 3
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 4
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses multiplication application");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "*"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "+"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "-"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 5
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "*"
          }
        },
        tl: {
          hd: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 2
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "-"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 5
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses nested applications correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "cons"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "empty"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "cons"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: /* EmptyE */0,
            tl: /* [] */0
          }
        }
      }
    }, "Parses cons expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "first"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "cons"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "empty"
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "first"
          }
        },
        tl: {
          hd: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "cons"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: {
                  hd: /* EmptyE */0,
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }
      }
    }, "Parses first expression correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "empty?"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "empty"
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "empty?"
          }
        },
        tl: {
          hd: /* EmptyE */0,
          tl: /* [] */0
        }
      }
    }, "Parses empty? correctly");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "not"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "not"
          }
        },
        tl: {
          hd: {
            TAG: /* BoolE */1,
            _0: true
          },
          tl: /* [] */0
        }
      }
    }, "Parses not-expression correctly");

function parseDefinition(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("missing a name and/or expression");
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("missing a name and/or expression");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 !== "define") {
                return Pervasives.failwith("missing a name and/or expression");
              }
              var match$2 = match.tl;
              if (!match$2) {
                return Pervasives.failwith("missing a name and/or expression");
              }
              var x = match$2.hd;
              switch (x.TAG | 0) {
                case /* SymbolC */1 :
                    var match$3 = match$2.tl;
                    if (match$3 && !match$3.tl) {
                      return [
                              /* Name */{
                                _0: x._0
                              },
                              parseExpression(match$3.hd)
                            ];
                    } else {
                      return Pervasives.failwith("missing a name and/or expression");
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("missing a name and/or expression");
                
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("missing a name and/or expression");
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseDefinition(Read$Rackette.Reader.read("(+ 1 2)"));
      }), "missing a name and/or expression");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define x 10)")), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumE */0,
        _0: 10
      }
    ], "Parses simple numeric define correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define flag true)")), [
      /* Name */{
        _0: "flag"
      },
      {
        TAG: /* BoolE */1,
        _0: true
      }
    ], "Parses boolean definition correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define lst empty)")), [
      /* Name */{
        _0: "lst"
      },
      /* EmptyE */0
    ], "Parses empty list definition correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define y (+ 5 3))")), [
      /* Name */{
        _0: "y"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 5
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 3
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "Parses arithmetic define correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define add1 (lambda (x) (+ x 1)))")), [
      /* Name */{
        _0: "add1"
      },
      {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "Parses define of a simple lambda function correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define add (lambda (x y) (+ x y)))")), [
      /* Name */{
        _0: "add"
      },
      {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: {
              hd: /* Name */{
                _0: "y"
              },
              tl: /* [] */0
            }
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "y"
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "Parses define of multi-parameter lambda correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 10
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumE */0,
        _0: 10
      }
    ], "Parses simple numeric define correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "cs17"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "cs17"
      },
      {
        TAG: /* BoolE */1,
        _0: true
      }
    ], "Parses boolean definition correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "lst"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "empty"
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "lst"
      },
      /* EmptyE */0
    ], "Parses empty list definition correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "y"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 5
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "y"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 5
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 3
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "Parses arithmetic define correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "add1"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "x"
                          },
                          tl: /* [] */0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* NumberC */0,
                                  _0: 1
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "add1"
      },
      {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "Parses define of a simple lambda function correctly");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "add"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "x"
                          },
                          tl: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "y"
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "y"
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "add"
      },
      {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: {
              hd: /* Name */{
                _0: "y"
              },
              tl: /* [] */0
            }
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "y"
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "Parses define of multi-parameter lambda correctly");

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(define x 5)")), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumE */0,
          _0: 5
        }
      ]
    }, "Produces a parsed Definition");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(define add (lambda (a b) (+ a b)))")), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "add"
        },
        {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "a"
              },
              tl: {
                hd: /* Name */{
                  _0: "b"
                },
                tl: /* [] */0
              }
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "a"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "b"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      ]
    }, "Parses a Lambda Definition Correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(+ 1 2)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 1
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 2
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "Parses an Expression Correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("((lambda (x) (lambda (y) (+ x y))) 3)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "x"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* LambdaE */7,
                _0: {
                  nameList: {
                    hd: /* Name */{
                      _0: "y"
                    },
                    tl: /* [] */0
                  },
                  lambdaBody: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "+"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "x"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "y"
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 3
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses a nested lambda expression correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(if true 1 0)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* BoolE */1,
            _0: true
          },
          trueExpr: {
            TAG: /* NumE */0,
            _0: 1
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 0
          }
        }
      }
    }, "Parses boolean expression correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumE */0,
          _0: 5
        }
      ]
    }, "Produces a parsed Definition");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "add"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "a"
                          },
                          tl: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "b"
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "a"
                              },
                              tl: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "b"
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "add"
        },
        {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "a"
              },
              tl: {
                hd: /* Name */{
                  _0: "b"
                },
                tl: /* [] */0
              }
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "a"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "b"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      ]
    }, "Parses a Lambda Definition Correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "+"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 1
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 2
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "Parses an Expression Correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "lambda"
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: /* [] */0
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "lambda"
                        },
                        tl: {
                          hd: {
                            TAG: /* ListC */2,
                            _0: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "y"
                              },
                              tl: /* [] */0
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* ListC */2,
                              _0: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "+"
                                },
                                tl: {
                                  hd: {
                                    TAG: /* SymbolC */1,
                                    _0: "x"
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* SymbolC */1,
                                      _0: "y"
                                    },
                                    tl: /* [] */0
                                  }
                                }
                              }
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 3
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "x"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* LambdaE */7,
                _0: {
                  nameList: {
                    hd: /* Name */{
                      _0: "y"
                    },
                    tl: /* [] */0
                  },
                  lambdaBody: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "+"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "x"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "y"
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 3
            },
            tl: /* [] */0
          }
        }
      }
    }, "Parses a nested lambda expression correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 1
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 0
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* BoolE */1,
            _0: true
          },
          trueExpr: {
            TAG: /* NumE */0,
            _0: 1
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 0
          }
        }
      }
    }, "Parses boolean expression correctly");

function parse(input) {
  return List.map(parsePiece, input);
}

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(define x 5) (define y 10)")), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 5
          }
        ]
      },
      tl: {
        hd: {
          TAG: /* Definition */0,
          _0: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* NumE */0,
              _0: 10
            }
          ]
        },
        tl: /* [] */0
      }
    }, "Parses Definitions");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(+ 1 2) (* 3 4)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: {
        hd: {
          TAG: /* Expression */1,
          _0: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "*"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 3
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 4
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        },
        tl: /* [] */0
      }
    }, "Parses expressions correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(define square (lambda (x) (* x x))) (square 5)")), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "square"
          },
          {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "x"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "*"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "x"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        ]
      },
      tl: {
        hd: {
          TAG: /* Expression */1,
          _0: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "square"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        },
        tl: /* [] */0
      }
    }, "Parses mix of definition and expression correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "define"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "x"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 5
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "define"
                },
                tl: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "y"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 10
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 5
          }
        ]
      },
      tl: {
        hd: {
          TAG: /* Definition */0,
          _0: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* NumE */0,
              _0: 10
            }
          ]
        },
        tl: /* [] */0
      }
    }, "Parses Definitions");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "+"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 1
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 2
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "*"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 3
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 4
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: {
        hd: {
          TAG: /* Expression */1,
          _0: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "*"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 3
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 4
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        },
        tl: /* [] */0
      }
    }, "Parses expressions correctly");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "define"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "square"
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "lambda"
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "x"
                            },
                            tl: /* [] */0
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* ListC */2,
                            _0: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "*"
                              },
                              tl: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "x"
                                },
                                tl: {
                                  hd: {
                                    TAG: /* SymbolC */1,
                                    _0: "x"
                                  },
                                  tl: /* [] */0
                                }
                              }
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "square"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 5
                  },
                  tl: /* [] */0
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "square"
          },
          {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "x"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "*"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "x"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        ]
      },
      tl: {
        hd: {
          TAG: /* Expression */1,
          _0: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "square"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        },
        tl: /* [] */0
      }
    }, "Parses mix of definition and expression correctly");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parsePiece({
                    TAG: /* ListC */2,
                    _0: /* [] */0
                  });
      }), "empty parentheses are not allowed as an input");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseDefinition({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "define"
                      },
                      tl: /* [] */0
                    }
                  });
      }), "missing a name and/or expression");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseDefinition({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "define"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "a"
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "missing a name and/or expression");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseDefinition({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "define"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 12
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "missing a name and/or expression");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "if"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "if requires 3 subexpressions");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "lambda"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "a"
                        },
                        tl: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "b"
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  });
      }), "invalid lambda syntax");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "let"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "a"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 5
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  });
      }), "invalid let syntax");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "and"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "and requires 2 subexpressions");

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseExpression({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "or"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "true"
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "or requires 2 subexpressions");

function $$eval(tle, _env, _expr) {
  while(true) {
    var expr = _expr;
    var env = _env;
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          var name = expr._0;
          var v = lookup(env, name);
          if (v !== undefined) {
            return v;
          }
          var v$1 = lookup(tle, name);
          if (v$1 !== undefined) {
            return v$1;
          } else {
            return Pervasives.failwith("the name is not associated to any environment");
          }
      case /* AndE */3 :
          var match = $$eval(tle, env, expr._0);
          if (match.TAG !== /* BoolV */1) {
            return Pervasives.failwith("A boolean value wasn't entered. Therefore, AndE cannot be executed.");
          }
          if (!match._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var b = $$eval(tle, env, expr._1);
          if (b.TAG === /* BoolV */1) {
            return {
                    TAG: /* BoolV */1,
                    _0: b._0
                  };
          } else {
            return Pervasives.failwith("A boolean value wasn't entered. Therefore, AndE cannot be executed.");
          }
      case /* OrE */4 :
          var match$1 = $$eval(tle, env, expr._0);
          if (match$1.TAG !== /* BoolV */1) {
            return Pervasives.failwith("A boolean value wasn't entered. Therefore, OrE cannot be executed.");
          }
          if (match$1._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var b$1 = $$eval(tle, env, expr._1);
          if (b$1.TAG === /* BoolV */1) {
            return {
                    TAG: /* BoolV */1,
                    _0: b$1._0
                  };
          } else {
            return Pervasives.failwith("A boolean value wasn't entered. Therefore, OrE cannot be executed.");
          }
      case /* IfE */5 :
          var match$2 = expr._0;
          var b$2 = $$eval(tle, env, match$2.boolExpr);
          if (b$2.TAG !== /* BoolV */1) {
            return Pervasives.failwith("if condition must evaluate to boolean");
          }
          if (b$2._0) {
            _expr = match$2.trueExpr;
            continue ;
          }
          _expr = match$2.falseExpr;
          continue ;
      case /* CondE */6 :
          var _lst = expr._0;
          while(true) {
            var lst = _lst;
            if (!lst) {
              return Pervasives.failwith("All conditions resulted in false, so nothing was executed.");
            }
            var firstCD = lst.hd;
            var b$3 = $$eval(tle, env, firstCD.conditionExpr);
            if (b$3.TAG !== /* BoolV */1) {
              return Pervasives.failwith("condition expression must evaluate to boolean");
            }
            if (b$3._0) {
              return $$eval(tle, env, firstCD.resultExpr);
            }
            _lst = lst.tl;
            continue ;
          };
      case /* LambdaE */7 :
          var match$3 = expr._0;
          var lst$1 = match$3.nameList;
          if (containsDuplicates(lst$1)) {
            return Pervasives.failwith("lambda has duplicate argument in argument list");
          } else {
            return {
                    TAG: /* ClosureV */4,
                    _0: {
                      cNameList: lst$1,
                      cExpr: match$3.lambdaBody,
                      cEnv: env
                    }
                  };
          }
      case /* LetE */8 :
          var match$4 = expr._0;
          var letPairsList = match$4.letPairs;
          var namesList = List.map((function (pairList) {
                  return pairList.pairName;
                }), letPairsList);
          if (containsDuplicates(namesList)) {
            return Pervasives.failwith("let has duplicate variable in binding");
          }
          var letEval = (function(env){
          return function letEval(_lpList, _l) {
            while(true) {
              var l = _l;
              var lpList = _lpList;
              if (!lpList) {
                return l;
              }
              var firstLP = lpList.hd;
              var restLPs = lpList.tl;
              var newBinding_0 = firstLP.pairName;
              var newBinding_1 = $$eval(tle, env, firstLP.pairExpr);
              var newBinding = [
                newBinding_0,
                newBinding_1
              ];
              if (l) {
                if (l.tl) {
                  return Pervasives.failwith("error");
                }
                _l = {
                  hd: List.cons(newBinding, l.hd),
                  tl: /* [] */0
                };
                _lpList = restLPs;
                continue ;
              }
              _l = {
                hd: List.cons(newBinding, /* [] */0),
                tl: /* [] */0
              };
              _lpList = restLPs;
              continue ;
            };
          }
          }(env));
          _expr = match$4.letBody;
          _env = Pervasives.$at(letEval(letPairsList, /* [] */0), env);
          continue ;
      case /* ApplicationE */9 :
          var expressionList = expr._0;
          if (!expressionList) {
            return Pervasives.failwith("cannot be empty, this error will already be detected by parse");
          }
          var restExps = expressionList.tl;
          var z = $$eval(tle, env, expressionList.hd);
          switch (z.TAG | 0) {
            case /* BuiltinV */3 :
                return Curry._1(z._0.bProc, List.map((function(env){
                              return function (x) {
                                return $$eval(tle, env, x);
                              }
                              }(env)), restExps));
            case /* ClosureV */4 :
                var closure = z._0;
                var listValues = List.map((function(env){
                    return function (x) {
                      return $$eval(tle, env, x);
                    }
                    }(env)), restExps);
                var listNames = closure.cNameList;
                var makeNewEnv = function (_env, _nameList, _valueList) {
                  while(true) {
                    var valueList = _valueList;
                    var nameList = _nameList;
                    var env = _env;
                    if (!nameList) {
                      if (valueList) {
                        return Pervasives.failwith("Mismatch in # of formals and actuals");
                      } else {
                        return env;
                      }
                    }
                    if (!valueList) {
                      return Pervasives.failwith("Mismatch in # of formals and actuals");
                    }
                    if (!env) {
                      return Pervasives.failwith("error");
                    }
                    if (env.tl) {
                      return Pervasives.failwith("error");
                    }
                    var newBinding_0 = nameList.hd;
                    var newBinding_1 = valueList.hd;
                    var newBinding = [
                      newBinding_0,
                      newBinding_1
                    ];
                    var updatedEnv_0 = List.cons(newBinding, env.hd);
                    var updatedEnv = {
                      hd: updatedEnv_0,
                      tl: /* [] */0
                    };
                    _valueList = valueList.tl;
                    _nameList = nameList.tl;
                    _env = updatedEnv;
                    continue ;
                  };
                };
                var newEnvL = makeNewEnv({
                      hd: /* [] */0,
                      tl: /* [] */0
                    }, listNames, listValues);
                var newExtendedEnv = Pervasives.$at(newEnvL, closure.cEnv);
                _expr = closure.cExpr;
                _env = newExtendedEnv;
                continue ;
            default:
              return Pervasives.failwith("cannot perform procecure-application on non-procedure values");
          }
      
    }
  };
}

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("y")));
      }), "the name is not associated to any environment");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and 677777 true)")));
      }), "A boolean value wasn't entered. Therefore, AndE cannot be executed.");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or 12342 false)")));
      }), "A boolean value wasn't entered. Therefore, OrE cannot be executed.");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(if 3 1 2)")));
      }), "if condition must evaluate to boolean");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(number? 1 2)")));
      }), "incorrect number of inputs: expected 1 argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(empty?)")));
      }), "incorrect number of inputs: expected 1 argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(first empty)")));
      }), "this procedure expects a non-empty list input");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(cond (false 1) ((= 1 2) 3))")));
      }), "All conditions resulted in false, so nothing was executed.");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(+ 1)")));
      }), "incorrect number of inputs: expected 2 arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(+ true 2)")));
      }), "Incorrect input type: expected numbers");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x y) (+ x y)) 67)")));
      }), "Mismatch in # of formals and actuals");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x) x) 6 7)")));
      }), "Mismatch in # of formals and actuals");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, {
                    TAG: /* ApplicationE */9,
                    _0: /* [] */0
                  });
      }), "cannot be empty, this error will already be detected by parse");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(horse 2 8)")));
      }), "the name is not associated to any environment");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(4 2 0)")));
      }), "cannot perform procecure-application on non-procedure values");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* LambdaE */7,
                        _0: {
                          nameList: {
                            hd: /* Name */{
                              _0: "a"
                            },
                            tl: {
                              hd: /* Name */{
                                _0: "b"
                              },
                              tl: /* [] */0
                            }
                          },
                          lambdaBody: {
                            TAG: /* ApplicationE */9,
                            _0: {
                              hd: {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: "+"
                                }
                              },
                              tl: {
                                hd: {
                                  TAG: /* NameE */2,
                                  _0: /* Name */{
                                    _0: "a"
                                  }
                                },
                                tl: {
                                  hd: {
                                    TAG: /* NameE */2,
                                    _0: /* Name */{
                                      _0: "b"
                                    }
                                  },
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Mismatch in # of formals and actuals");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, {
                    TAG: /* LambdaE */7,
                    _0: {
                      nameList: {
                        hd: /* Name */{
                          _0: "a"
                        },
                        tl: {
                          hd: /* Name */{
                            _0: "a"
                          },
                          tl: /* [] */0
                        }
                      },
                      lambdaBody: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "+"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "a"
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* NumE */0,
                                _0: 1
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  });
      }), "lambda has duplicate argument in argument list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, {
                    TAG: /* LetE */8,
                    _0: {
                      letPairs: {
                        hd: {
                          pairName: /* Name */{
                            _0: "a"
                          },
                          pairExpr: {
                            TAG: /* NumE */0,
                            _0: 1
                          }
                        },
                        tl: {
                          hd: {
                            pairName: /* Name */{
                              _0: "a"
                            },
                            pairExpr: {
                              TAG: /* NumE */0,
                              _0: 2
                            }
                          },
                          tl: /* [] */0
                        }
                      },
                      letBody: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "a"
                        }
                      }
                    }
                  });
      }), "let has duplicate variable in binding");

CS17SetupRackette$Rackette.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* LambdaE */7,
                        _0: {
                          nameList: {
                            hd: /* Name */{
                              _0: "a"
                            },
                            tl: {
                              hd: /* Name */{
                                _0: "b"
                              },
                              tl: /* [] */0
                            }
                          },
                          lambdaBody: {
                            TAG: /* ApplicationE */9,
                            _0: {
                              hd: {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: "/"
                                }
                              },
                              tl: {
                                hd: {
                                  TAG: /* NameE */2,
                                  _0: /* Name */{
                                    _0: "a"
                                  }
                                },
                                tl: {
                                  hd: {
                                    TAG: /* NameE */2,
                                    _0: /* Name */{
                                      _0: "b"
                                    }
                                  },
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Mismatch in # of formals and actuals");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* NumE */0,
          _0: 5
        }), {
      TAG: /* NumV */0,
      _0: 5
    }, "Evaluates number");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* BoolE */1,
          _0: true
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Evaluates true");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* BoolE */1,
          _0: false
        }), {
      TAG: /* BoolV */1,
      _0: false
    }, "Evaluates false");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, /* EmptyE */0), {
      TAG: /* ListV */2,
      _0: /* [] */0
    }, "Evaluates empty to empty list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 1
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 2
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "If true branch works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* BoolE */1,
              _0: false
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 1
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 2
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 2
    }, "If false branch works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* BoolE */1,
            _0: false
          }
        }), {
      TAG: /* BoolV */1,
      _0: false
    }, "And short-circuits false");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "And both true");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* BoolE */1,
            _0: false
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Or short-circuits true");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Or evaluates second expression");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* CondE */6,
          _0: {
            hd: {
              conditionExpr: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: ">"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 3
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 1
              }
            },
            tl: {
              hd: {
                conditionExpr: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "<"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 3
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                resultExpr: {
                  TAG: /* NumE */0,
                  _0: 0
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "Cond picks first true branch");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 6
    }, "Single-argument lambda application");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: {
                    hd: /* Name */{
                      _0: "y"
                    },
                    tl: /* [] */0
                  }
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "y"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 3
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 4
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 7
    }, "Multi-argument lambda application");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* LambdaE */7,
                      _0: {
                        nameList: {
                          hd: /* Name */{
                            _0: "y"
                          },
                          tl: /* [] */0
                        },
                        lambdaBody: {
                          TAG: /* ApplicationE */9,
                          _0: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "+"
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: "x"
                                }
                              },
                              tl: {
                                hd: {
                                  TAG: /* NameE */2,
                                  _0: /* Name */{
                                    _0: "y"
                                  }
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 7
    }, "Closure retains outer x binding");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* LetE */8,
          _0: {
            letPairs: {
              hd: {
                pairName: /* Name */{
                  _0: "x"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 5
                }
              },
              tl: {
                hd: {
                  pairName: /* Name */{
                    _0: "y"
                  },
                  pairExpr: {
                    TAG: /* NumE */0,
                    _0: 10
                  }
                },
                tl: /* [] */0
              }
            },
            letBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "y"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 15
    }, "Let binds local variables and evaluates body");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* LetE */8,
          _0: {
            letPairs: {
              hd: {
                pairName: /* Name */{
                  _0: "x"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 2
                }
              },
              tl: /* [] */0
            },
            letBody: {
              TAG: /* LetE */8,
              _0: {
                letPairs: {
                  hd: {
                    pairName: /* Name */{
                      _0: "x"
                    },
                    pairExpr: {
                      TAG: /* NumE */0,
                      _0: 3
                    }
                  },
                  tl: /* [] */0
                },
                letBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 4
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 7
    }, "Inner let shadows outer let variable");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "*"
              }
            },
            tl: {
              hd: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "+"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "-"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 5
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 6
    }, "Nested application evaluates correctly");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "cons"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: {
                hd: /* EmptyE */0,
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 1
        },
        tl: /* [] */0
      }
    }, "Cons builds a single-element list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "first"
              }
            },
            tl: {
              hd: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "cons"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "cons"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NumE */0,
                              _0: 2
                            },
                            tl: {
                              hd: /* EmptyE */0,
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "First returns head of list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "rest"
              }
            },
            tl: {
              hd: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "cons"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "cons"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NumE */0,
                              _0: 2
                            },
                            tl: {
                              hd: /* EmptyE */0,
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 2
        },
        tl: /* [] */0
      }
    }, "Rest returns tail of list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "empty?"
              }
            },
            tl: {
              hd: /* EmptyE */0,
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Empty? returns true on empty list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "<"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 2
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Less-than comparison works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: ">"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Greater-than comparison works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "="
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "Equality comparison works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(if true 1 2)"))), {
      TAG: /* NumV */0,
      _0: 1
    }, "If true branch works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(if false 1 2)"))), {
      TAG: /* NumV */0,
      _0: 2
    }, "If false branch works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and true false)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "And short-circuits false");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and true true)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "And both true");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or true false)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Or short-circuits true");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or false true)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Or evaluates second expression");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(cond ((> 3 2) 1) ((< 3 2) 0))"))), {
      TAG: /* NumV */0,
      _0: 1
    }, "Cond picks first true branch");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression({
              TAG: /* ListC */2,
              _0: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "cond"
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "<"
                          },
                          tl: {
                            hd: {
                              TAG: /* NumberC */0,
                              _0: 2
                            },
                            tl: {
                              hd: {
                                TAG: /* NumberC */0,
                                _0: 3
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            })), {
      TAG: /* NumV */0,
      _0: 1
    }, "Cond picks only true branch");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x) (+ x 1)) 5)"))), {
      TAG: /* NumV */0,
      _0: 6
    }, "Single-argument lambda application");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x y) (+ x y)) 3 4)"))), {
      TAG: /* NumV */0,
      _0: 7
    }, "Multi-argument lambda application");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x) ((lambda (y) (+ x y)) 2)) 5)"))), {
      TAG: /* NumV */0,
      _0: 7
    }, "Closure retains outer x binding");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(let ((x 5) (y 10)) (+ x y))"))), {
      TAG: /* NumV */0,
      _0: 15
    }, "Let binds local variables and evaluates body");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(let ((x 2)) (let ((x 3)) (+ x 4)))"))), {
      TAG: /* NumV */0,
      _0: 7
    }, "Inner let shadows outer let variable");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(* (+ 1 2) (- 5 3))"))), {
      TAG: /* NumV */0,
      _0: 6
    }, "Nested application evaluates correctly");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(cons 1 empty)"))), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 1
        },
        tl: /* [] */0
      }
    }, "Cons builds a single-element list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(first (cons 1 (cons 2 empty)))"))), {
      TAG: /* NumV */0,
      _0: 1
    }, "First returns head of list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(rest (cons 1 (cons 2 empty)))"))), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 2
        },
        tl: /* [] */0
      }
    }, "Rest returns tail of list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(empty? empty)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Empty? returns true on empty list");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(< 2 3)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Less-than comparison works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(> 4 2)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Greater-than comparison works");

CS17SetupRackette$Rackette.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(= 5 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "Equality comparison works");

function addDefinition(env, param) {
  var id = param[0];
  var match = lookup(env, id);
  if (match !== undefined) {
    return Pervasives.failwith("Error: name is already in tle");
  }
  var x = $$eval(env, /* [] */0, param[1]);
  if (env && !env.tl) {
    return {
            hd: Pervasives.$at({
                  hd: [
                    id,
                    x
                  ],
                  tl: /* [] */0
                }, env.hd),
            tl: /* [] */0
          };
  } else {
    return Pervasives.failwith("Error: env cannot be empty because initialTle already has a binding.");
  }
}

CS17SetupRackette$Rackette.checkError((function (param) {
        return addDefinition({
                    hd: {
                      hd: [
                        /* Name */{
                          _0: "x"
                        },
                        {
                          TAG: /* NumV */0,
                          _0: 1
                        }
                      ],
                      tl: /* [] */0
                    },
                    tl: /* [] */0
                  }, [
                    /* Name */{
                      _0: "x"
                    },
                    {
                      TAG: /* NumE */0,
                      _0: 2
                    }
                  ]);
      }), "Error: name is already in tle");

CS17SetupRackette$Rackette.checkError((function (param) {
        return addDefinition(/* [] */0, [
                    /* Name */{
                      _0: "z"
                    },
                    {
                      TAG: /* NumE */0,
                      _0: 3
                    }
                  ]);
      }), "Error: env cannot be empty because initialTle already has a binding.");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: /* [] */0,
          tl: /* [] */0
        }, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 5
          }
        ]), {
      hd: {
        hd: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumV */0,
            _0: 5
          }
        ],
        tl: /* [] */0
      },
      tl: /* [] */0
    }, "addDefinition: basic numeric binding");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: /* [] */0,
          tl: /* [] */0
        }, [
          /* Name */{
            _0: "bool"
          },
          {
            TAG: /* BoolE */1,
            _0: false
          }
        ]), {
      hd: {
        hd: [
          /* Name */{
            _0: "bool"
          },
          {
            TAG: /* BoolV */1,
            _0: false
          }
        ],
        tl: /* [] */0
      },
      tl: /* [] */0
    }, "addDefinition: boolean definition");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: /* [] */0,
          tl: /* [] */0
        }, [
          /* Name */{
            _0: "lst"
          },
          /* EmptyE */0
        ]), {
      hd: {
        hd: [
          /* Name */{
            _0: "lst"
          },
          {
            TAG: /* ListV */2,
            _0: /* [] */0
          }
        ],
        tl: /* [] */0
      },
      tl: /* [] */0
    }, "addDefinition: define empty list");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: /* [] */0,
          tl: /* [] */0
        }, parseDefinition(Read$Rackette.Reader.read("(define a 10)"))), {
      hd: {
        hd: [
          /* Name */{
            _0: "a"
          },
          {
            TAG: /* NumV */0,
            _0: 10
          }
        ],
        tl: /* [] */0
      },
      tl: /* [] */0
    }, "addDefinition: basic numeric binding");

CS17SetupRackette$Rackette.checkExpect(lookup(addDefinition(initialTle, [
              /* Name */{
                _0: "a"
              },
              {
                TAG: /* NumE */0,
                _0: 5
              }
            ]), /* Name */{
          _0: "a"
        }), {
      TAG: /* NumV */0,
      _0: 5
    }, "addDefinition: adds numeric definition to top-level env");

CS17SetupRackette$Rackette.checkExpect(lookup(addDefinition(initialTle, [
              /* Name */{
                _0: "bool"
              },
              {
                TAG: /* BoolE */1,
                _0: true
              }
            ]), /* Name */{
          _0: "bool"
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "addDefinition: adds boolean definition");

CS17SetupRackette$Rackette.checkExpect(lookup(addDefinition(initialTle, [
              /* Name */{
                _0: "numbers"
              },
              {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "cons"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "cons"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NumE */0,
                              _0: 10
                            },
                            tl: {
                              hd: /* EmptyE */0,
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            ]), /* Name */{
          _0: "numbers"
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 5
        },
        tl: {
          hd: {
            TAG: /* NumV */0,
            _0: 10
          },
          tl: /* [] */0
        }
      }
    }, "addDefinition: creates list using cons");

CS17SetupRackette$Rackette.checkExpect(lookup(addDefinition(initialTle, [
              /* Name */{
                _0: "sum"
              },
              {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "+"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 2
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 3
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            ]), /* Name */{
          _0: "sum"
        }), {
      TAG: /* NumV */0,
      _0: 5
    }, "addDefinition: adds evaluated sum");

function stringOfValue(aValue) {
  switch (aValue.TAG | 0) {
    case /* NumV */0 :
        return String(aValue._0);
    case /* BoolV */1 :
        return Pervasives.string_of_bool(aValue._0);
    case /* ListV */2 :
        var x = aValue._0;
        if (x) {
          return "(list " + (List.fold_left((function (y, z) {
                          return y + (" " + stringOfValue(z));
                        }), stringOfValue(x.hd), x.tl) + ")");
        } else {
          return "'()";
        }
    case /* BuiltinV */3 :
        return aValue._0.printedRep;
    case /* ClosureV */4 :
        return "<User-defined procedure>";
    
  }
}

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* NumV */0,
          _0: 42
        }), "42", "Evaluates a num");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* BoolV */1,
          _0: true
        }), "true", "Evaluates a boolean");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* BoolV */1,
          _0: false
        }), "false", "Evaluates a boolean");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ClosureV */4,
          _0: {
            cNameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            cExpr: {
              TAG: /* NumE */0,
              _0: 10
            },
            cEnv: /* [] */0
          }
        }), "<User-defined procedure>", "Evaluates a user defined closure");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: /* [] */0
        }), "'()", "Evaluates an empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* NumV */0,
              _0: 1
            },
            tl: {
              hd: {
                TAG: /* NumV */0,
                _0: 2
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            }
          }
        }), "(list 1 2 3)", "Evaluates a list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* NumV */0,
              _0: 1
            },
            tl: {
              hd: {
                TAG: /* BoolV */1,
                _0: true
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }), "(list 1 true 5)", "Evaluates a list of mixed types");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* NumV */0,
              _0: 1
            },
            tl: {
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 2
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 4
                },
                tl: /* [] */0
              }
            }
          }
        }), "(list 1 (list 2 3) 4)", "Evaluates a nested list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* NumE */0,
              _0: 42
            })), "42", "Evaluates a num");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* BoolE */1,
              _0: true
            })), "true", "Evaluates a boolean true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* BoolE */1,
              _0: false
            })), "false", "Evaluates a boolean false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* NumE */0,
                  _0: 10
                }
              }
            })), "<User-defined procedure>", "Evaluates a user-defined closure");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, /* EmptyE */0)), "'()", "Evaluates an empty list");

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Expression */1,
            _0: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 2
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: /* [] */0
    }, "Evaluates a simple operation");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Expression */1,
            _0: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: {
            hd: {
              TAG: /* Expression */1,
              _0: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "*"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 3
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 4
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 2
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 12
        },
        tl: /* [] */0
      }
    }, "Evaluates multiple operations");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Definition */0,
            _0: [
              /* Name */{
                _0: "x"
              },
              {
                TAG: /* NumE */0,
                _0: 10
              }
            ]
          },
          tl: {
            hd: {
              TAG: /* Expression */1,
              _0: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "+"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "x"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 5
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Adds a definition and evaluates an expression using it");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Definition */0,
            _0: [
              /* Name */{
                _0: "square"
              },
              {
                TAG: /* LambdaE */7,
                _0: {
                  nameList: {
                    hd: /* Name */{
                      _0: "n"
                    },
                    tl: /* [] */0
                  },
                  lambdaBody: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "*"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "n"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "n"
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          tl: {
            hd: {
              TAG: /* Expression */1,
              _0: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "square"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 6
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 36
      },
      tl: /* [] */0
    }, "Defines a function and then makes use of it");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Definition */0,
            _0: [
              /* Name */{
                _0: "a"
              },
              {
                TAG: /* NumE */0,
                _0: 2
              }
            ]
          },
          tl: {
            hd: {
              TAG: /* Definition */0,
              _0: [
                /* Name */{
                  _0: "b"
                },
                {
                  TAG: /* NumE */0,
                  _0: 3
                }
              ]
            },
            tl: {
              hd: {
                TAG: /* Expression */1,
                _0: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "a"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "b"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* Expression */1,
                  _0: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "*"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "a"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "b"
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 6
        },
        tl: /* [] */0
      }
    }, "Tests multiple definitions and their uses");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Definition */0,
            _0: [
              /* Name */{
                _0: "makeAdder"
              },
              {
                TAG: /* LambdaE */7,
                _0: {
                  nameList: {
                    hd: /* Name */{
                      _0: "x"
                    },
                    tl: /* [] */0
                  },
                  lambdaBody: {
                    TAG: /* LambdaE */7,
                    _0: {
                      nameList: {
                        hd: /* Name */{
                          _0: "y"
                        },
                        tl: /* [] */0
                      },
                      lambdaBody: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "+"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "x"
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: "y"
                                }
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          tl: {
            hd: {
              TAG: /* Expression */1,
              _0: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "makeAdder"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 10
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Tests scope and closure evaluation");

CS17SetupRackette$Rackette.checkExpect($$process({
          hd: {
            TAG: /* Expression */1,
            _0: {
              TAG: /* IfE */5,
              _0: {
                boolExpr: {
                  TAG: /* BoolE */1,
                  _0: true
                },
                trueExpr: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                falseExpr: {
                  TAG: /* NumE */0,
                  _0: 2
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 1
      },
      tl: /* [] */0
    }, "Tests conditional expression");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "+"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 2
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 3
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: /* [] */0
    }, "Evaluates a simple operation");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "+"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 1
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "*"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 3
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 4
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 2
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 12
        },
        tl: /* [] */0
      }
    }, "Evaluates multiple operations");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "define"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "x"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 10
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Adds a definition and evaluates an expression using it");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "define"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "square"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "lambda"
                          },
                          tl: {
                            hd: {
                              TAG: /* ListC */2,
                              _0: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "n"
                                },
                                tl: /* [] */0
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* ListC */2,
                                _0: {
                                  hd: {
                                    TAG: /* SymbolC */1,
                                    _0: "*"
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* SymbolC */1,
                                      _0: "n"
                                    },
                                    tl: {
                                      hd: {
                                        TAG: /* SymbolC */1,
                                        _0: "n"
                                      },
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "square"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 6
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 36
      },
      tl: /* [] */0
    }, "Defines a function and then makes use of it");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "define"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "a"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "define"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "b"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "+"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "a"
                        },
                        tl: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "b"
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "*"
                        },
                        tl: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "a"
                          },
                          tl: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "b"
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 6
        },
        tl: /* [] */0
      }
    }, "Tests multiple definitions and their uses");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "define"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "makeAdder"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "lambda"
                          },
                          tl: {
                            hd: {
                              TAG: /* ListC */2,
                              _0: {
                                hd: {
                                  TAG: /* SymbolC */1,
                                  _0: "x"
                                },
                                tl: /* [] */0
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* ListC */2,
                                _0: {
                                  hd: {
                                    TAG: /* SymbolC */1,
                                    _0: "lambda"
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* ListC */2,
                                      _0: {
                                        hd: {
                                          TAG: /* SymbolC */1,
                                          _0: "y"
                                        },
                                        tl: /* [] */0
                                      }
                                    },
                                    tl: {
                                      hd: {
                                        TAG: /* ListC */2,
                                        _0: {
                                          hd: {
                                            TAG: /* SymbolC */1,
                                            _0: "+"
                                          },
                                          tl: {
                                            hd: {
                                              TAG: /* SymbolC */1,
                                              _0: "x"
                                            },
                                            tl: {
                                              hd: {
                                                TAG: /* SymbolC */1,
                                                _0: "y"
                                              },
                                              tl: /* [] */0
                                            }
                                          }
                                        }
                                      },
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "makeAdder"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 10
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 5
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Tests scope and closure evaluation");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "if"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "true"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              },
              tl: /* [] */0
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 1
      },
      tl: /* [] */0
    }, "Tests conditional expression");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(+ 2 3)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: /* [] */0
    }, "Evaluates a simple operation");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(+ 1 1) (* 3 4)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 2
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 12
        },
        tl: /* [] */0
      }
    }, "Evaluates multiple operations");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(define x 10) (+ x 5)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Adds a definition and evaluates an expression using it");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(define square (lambda (n) (* n n))) (square 6)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 36
      },
      tl: /* [] */0
    }, "Defines a function and then makes use of it");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(define a 2) (define b 3) (+ a b) (* a b)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: {
        hd: {
          TAG: /* NumV */0,
          _0: 6
        },
        tl: /* [] */0
      }
    }, "Tests multiple definitions and their uses");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(define makeAdder (lambda (x) (lambda (y) (+ x y)))) ((makeAdder 10) 5)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 15
      },
      tl: /* [] */0
    }, "Tests scope and closure evaluation");

CS17SetupRackette$Rackette.checkExpect($$process(List.map(parsePiece, Read$Rackette.Reader.readAll("(if true 1 2)"))), {
      hd: {
        TAG: /* NumV */0,
        _0: 1
      },
      tl: /* [] */0
    }, "Tests conditional expression");

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackette$Rackette.checkExpect(rackette("(+ 2 3)"), {
      hd: "5",
      tl: /* [] */0
    }, "Checks basic arithmetic");

CS17SetupRackette$Rackette.checkExpect(rackette("(* 2 3) (+ 10 5)"), {
      hd: "6",
      tl: {
        hd: "15",
        tl: /* [] */0
      }
    }, "Tests multiple expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("(define x 10) (+ x 5)"), {
      hd: "15",
      tl: /* [] */0
    }, "Tests simple variable definition and use");

CS17SetupRackette$Rackette.checkExpect(rackette("(if true 42 0)"), {
      hd: "42",
      tl: /* [] */0
    }, "Tests conditionals");

CS17SetupRackette$Rackette.checkExpect(rackette("\n    (define a 2)\n    (define b 3)\n    (+ a b)\n    (* a b)\n  "), {
      hd: "5",
      tl: {
        hd: "6",
        tl: /* [] */0
      }
    }, "Tests multiple defenitions and sequential printing");

CS17SetupRackette$Rackette.checkExpect(rackette("(and true (or false true))"), {
      hd: "true",
      tl: /* [] */0
    }, "Tests boolean logic");

CS17SetupRackette$Rackette.checkExpect(rackette("empty"), {
      hd: "'()",
      tl: /* [] */0
    }, "Checks empty list");

CS17SetupRackette$Rackette.checkExpect(rackette("(cond ((> 3 2) 1) ((< 3 2) 0))"), {
      hd: "1",
      tl: /* [] */0
    }, "Cond chooses the first true branch");

CS17SetupRackette$Rackette.checkExpect(rackette("(cond ((< 3 2) 0) ((= 4 4) 99))"), {
      hd: "99",
      tl: /* [] */0
    }, "Cond skips false branch and uses the true one");

CS17SetupRackette$Rackette.checkExpect(rackette("(if false (+ 1 2) (+ 3 4))"), {
      hd: "7",
      tl: /* [] */0
    }, "If expression evaluates the false branch only");

CS17SetupRackette$Rackette.checkExpect(rackette("(if true (+ 10 2) (/ 1 0))"), {
      hd: "12",
      tl: /* [] */0
    }, "If short-circuits and ignores false branch evaluation");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 5) (y 10)) (+ x y))"), {
      hd: "15",
      tl: /* [] */0
    }, "Let binds local variables and evaluates body");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 2)) (let ((x 3)) (+ x 4)))"), {
      hd: "7",
      tl: /* [] */0
    }, "Inner let shadows outer let variable");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((a 1) (b 2) (c 3)) (* (+ a b) c))"), {
      hd: "9",
      tl: /* [] */0
    }, "Let handles multiple bindings and nested arithmetic");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x) (+ x 1)) 5)"), {
      hd: "6",
      tl: /* [] */0
    }, "Simple single-argument lambda application");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y) (+ x y)) 3 4)"), {
      hd: "7",
      tl: /* [] */0
    }, "Multi-argument lambda application");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x) ((lambda (y) (+ x y)) 2)) 5)"), {
      hd: "7",
      tl: /* [] */0
    }, "Nested lambda application");

CS17SetupRackette$Rackette.checkExpect(rackette("\n    (define makeAdder (lambda (x) (lambda (y) (+ x y))))\n    ((makeAdder 10) 5)\n  "), {
      hd: "15",
      tl: /* [] */0
    }, "Defines a function with a lmbda");

CS17SetupRackette$Rackette.checkExpect(rackette("\n    (define square (lambda (n) (* n n)))\n    (define applyTwice (lambda (f x) (f (f x))))\n    (applyTwice square 2)\n  "), {
      hd: "16",
      tl: /* [] */0
    }, "Defines two functions");

CS17SetupRackette$Rackette.checkExpect(rackette("(cons 1 empty)"), {
      hd: "(list 1)",
      tl: /* [] */0
    }, "Cons builds a single-element list");

CS17SetupRackette$Rackette.checkExpect(rackette("(first (cons 1 (cons 2 empty)))"), {
      hd: "1",
      tl: /* [] */0
    }, "First returns head of list");

CS17SetupRackette$Rackette.checkExpect(rackette("(rest (cons 1 (cons 2 empty)))"), {
      hd: "(list 2)",
      tl: /* [] */0
    }, "Rest returns tail of list");

CS17SetupRackette$Rackette.checkExpect(rackette("(empty? empty)"), {
      hd: "true",
      tl: /* [] */0
    }, "Empty? correctly identifies an empty list");

CS17SetupRackette$Rackette.checkExpect(rackette("(empty? (cons 1 empty))"), {
      hd: "false",
      tl: /* [] */0
    }, "Empty? correctly identifies a non-empty list");

CS17SetupRackette$Rackette.checkExpect(rackette("\n    (define x 5)\n    (define addX (lambda (y) (+ x y)))\n    (let ((x 100)) (addX 2))\n  "), {
      hd: "7",
      tl: /* [] */0
    }, "Closure retains outer variable value");

CS17SetupRackette$Rackette.checkExpect(rackette("\n    (define factorial\n      (lambda (n)\n        (if (= n 0)\n            1\n            (* n (factorial (- n 1))))))\n    (factorial 5)\n  "), {
      hd: "120",
      tl: /* [] */0
    }, "Recursive factorial definition and call");

exports.initialTle = initialTle;
exports.containsDuplicates = containsDuplicates;
exports.lookup = lookup;
exports.test = test;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.stringOfValue = stringOfValue;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
